<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Compiler - Ian Laffey</title>
  <link rel="icon" type="image/x-icon" href="assets/images/favicon.ico">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: #2A1F1D;
      color: #DEC165;
      font-family: 'JetBrains Mono', monospace;
      font-size: 15px;
      line-height: 1.6;
      min-height: 100vh;
      padding: 40px 20px;
    }

    ::selection {
      background: #BE8A13;
      color: #2A1F1D;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .nav-back {
      margin-bottom: 40px;
    }

    .back-button {
      display: inline-block;
      padding: 10px 20px;
      background: transparent;
      color: #E6A96B;
      border: 1px solid #E6A96B;
      text-decoration: none;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.05em;
      transition: all 0.2s ease;
    }

    .back-button:hover {
      background: #BE8A13;
      color: #2A1F1D;
      border-color: #BE8A13;
    }

    .project-header {
      text-align: center;
      margin-bottom: 60px;
      padding-bottom: 40px;
      border-bottom: 1px solid #7F6A55;
    }

    .project-title {
      font-size: 36px;
      font-weight: 700;
      color: #FFEAA3;
      margin-bottom: 16px;
      letter-spacing: -0.02em;
    }

    .project-meta {
      font-size: 14px;
      color: #7F6A55;
      line-height: 1.8;
    }

    .project-meta span {
      display: block;
    }

    pre {
      background: rgba(0, 0, 0, 0.35);
      padding: 16px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 24px 0;
      border: 1px solid #7F6A55;
    }

    code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: #FFEAA3;
      display: block;
      white-space: pre;
    }

    h2 {
      font-size: 24px;
      font-weight: 700;
      color: #FFCB1B;
      margin-bottom: 20px;
      margin-top: 40px;
      letter-spacing: -0.02em;
    }

    h3 {
      font-size: 18px;
      font-weight: 600;
      color: #E6A96B;
      margin-bottom: 16px;
      margin-top: 32px;
    }

    h4 {
      font-size: 16px;
      font-weight: 600;
      color: #BFC65A;
      margin-bottom: 12px;
      margin-top: 24px;
    }

    p {
      margin-bottom: 16px;
      color: #DEC165;
    }

    a {
      color: #7CC9CF;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    a:hover {
      color: #FFCB1B;
    }

    ul {
      margin-bottom: 20px;
      padding-left: 24px;
    }

    ul li {
      margin-bottom: 8px;
      color: #DEC165;
    }

    ul li::marker {
      color: #7F6A55;
    }

    .page-footer {
      margin-top: 80px;
      padding-top: 40px;
      border-top: 1px solid #7F6A55;
      text-align: center;
    }

    .footer-nav {
      margin-bottom: 40px;
    }

    .copyright {
      font-size: 13px;
      color: #7F6A55;
    }
  </style>
</head>

<body>
  <div class="container">
    <nav class="nav-back">
      <a href="./work.html" class="back-button">‚Üê Back</a>
    </nav>

    <header class="project-header">
      <h1 class="project-title">C Compiler</h1>
      <div class="project-meta">
        <span>McGill University</span>
        <span>2021</span>
      </div>
    </header>


    <div class="content-section">
      <p>Created a C Compiler, in Java from scratch. This included lexer, parser, AST generator, semantic analyzer, and
        regalloc. This was an individual project. Some boilerplate code by Christophe Dubach.</p>
      <p>Sadly, as this is for a <a href="https://www.cs.mcgill.ca/~cs520/2021/index.html">class at McGill</a>, and the
        course content is static, it is not open source.</p>

      <h2>Takeaways</h2>
      <p>
        A compiler is actually just a massive collection of very straightforward things.
        There weren't too many crazy algorithms or bits of Java syntax required.
      </p>

      <p>
        Writing such a large scale program myself gave me practice with abstracting and focusing on different parts of a
        program at a time, and learning where to look when debugging. In contrast to a larger, group project where it's
        probably someone else's fault if something was broken outside of the section I'm currently working in, here I
        had
        to switch gears if I discovered a bug in something previously written.
      </p>

      <p>
        Since register allocation is really just graph building and coloring, I got lots of hands-on experience with
        graph related algorithms. It was also nice to apply theoretical syntax, semantic, and typing rules I've
        encountered
        in other classes (although they can be much trickier than they are here).
      </p>

      <p>
        This project was a big confidence builder in my coding abilities.<br>
        Obviously, I learned a lot about how Compilers function behind the scenes.<br>
        Surprisingly, I did not learn anything new about C, since I was not actually writing the compiler in C.
      </p>

      <h2>What's Going On</h2>
      <h3>Lexer</h3>
      <p>
        By far the most simple part of the compiler, the Lexer generates tokens from input text.
      </p>

      <p>
        The Tokenizer was basically a long switch statement with checks: whitespace had to be ignored, and comment
        strings recognized.
      </p>

      <p>
        The Token object contains additional information, like position and character type
        (char, int).
      </p>

      <p>
        A simple Scanner was created, feeding data into the Tokenizer, which then created Token objects.
      </p>


      <h3>Parser</h3>
      <p>Verify the syntax of the <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF
          Grammar</a> representing a subset of C - "Mini C"</p>

      <pre><code># ::=
        # () grouping
        # [] optional
        # {} zero or more
        # + one or more
        # | alternative
        
        program   ::= (include)* (structdecl)* (vardecl)* (funcdecl)* EOF
        
        include   ::= "#include" STRING_LITERAL
        
        structdecl ::= structtype "{" (vardecl)* "}" ";"   # structure declaration
        
        vardecl   ::= type IDENT ";"
                     | type IDENT "[" INT_LITERAL "]" ";"  # array declaration, e.g. int a[2];
        
        funcdecl  ::= type IDENT "(" params ")" block      # function declaration
        
        type      ::= ("int" | "char" | "void" | structtype) ["*"]
        structtype ::= "struct" IDENT
        
        params    ::= [ type IDENT ("," type IDENT)* ]
        
        stmt      ::= block
                     | "while" "(" exp ")" stmt            # while loop
                     | "if" "(" exp ")" stmt ["else" stmt] # if then else
                     | "return" [exp] ";"
                     | exp "=" exp ";"
                     | exp ";"
        
        block     ::= "{" (vardecl)* (stmt)* "}"
        
        exp       ::= "(" exp ")"
                     | (IDENT | INT_LITERAL)
                     | ("-" | "!") exp
                     | CHARLITERAL
                     | STRING_LITERAL
                     | exp ("*" | "/" | "%" | "+" | "-" | "<" | ">" | "<=" | ">=" | "==" | "!=" | "&&" | "||") exp  # binary operators
                     | arrayaccess | fieldaccess | valueat | addressof | funcall | sizeof | typecast
        
        funcall   ::= IDENT "(" [ exp ("," exp)* ] ")"     # function call
        arrayaccess ::= exp "[" exp "]"                    # array access
        fieldaccess ::= exp "." IDENT                      # structure field member access
        valueat   ::= "*" exp                              # Value at operator (pointer indirection)
        addressof ::= "&" exp                              # Address-of operator
        sizeof    ::= "sizeof" "(" type ")"                # size of type
        typecast  ::= "(" type ")" exp                     # type casting
        </code></pre>
      <pre><code>| Precedence | Operator | Description                         | Associativity   |
        |------------|----------|-------------------------------------|-----------------|
        | 1          | ()       | Function call                       | Left-to-right   |
        | 1          | []       | Array subscripting                  | Left-to-right   |
        | 1          | .        | Structure member access             | Left-to-right   |
        | 2          | +        | Unary plus                          | Right-to-left   |
        | 2          | -        | Unary minus                         | Right-to-left   |
        | 2          | (type)   | Type cast                           | Right-to-left   |
        | 2          | *        | Indirection                         | Right-to-left   |
        | 2          | &        | Address of                          | Right-to-left   |
        | 3          | * / %    | Multiplication, division, remainder | Left-to-right   |
        | 4          | + -      | Addition, subtraction               | Left-to-right   |
        | 5          | < <= > >=| Relational operators                | Left-to-right   |
        | 6          | == !=    | Relational operators                | Left-to-right   |
        | 7          | &&       | Logical AND                         | Left-to-right   |
        | 8          | \|\|     | Logical OR                          | Left-to-right   |
        </code></pre>

      <p>A recursive descent parser was used...</p>

      <pre><code>private Program parseProgram() {
        parseIncludes();
    
        // THESE ARE ALL LOOPS
        List<StructTypeDecl> stds = parseStructDecls();
        List<VarDecl> vds = parseVarDeclsRep();
        List<FunDecl> fds = parseFunDecls();
    
        expect(TokenClass.EOF);
        return new Program(stds, vds, fds);
    }
    </code></pre>

      <p>The parser checks syntax and stores parsed info in an AST...</p>

      <h3>AST</h3>
      <pre><code>// The program AST node (a list of struct type declarations, list of variable declarations, list of FunDecl definitions)
        Program ::= StructTypeDecl* VarDecl* FunDecl*
        
        // Types
        Type ::= BaseType | PointerType | StructType | ArrayType
        
        BaseType ::= INT | CHAR | VOID
        PointerType ::= Type "*"             // use to represent pointers to other types
        StructType ::= String                // represent a struct type (the String is the name of the declared struct type)
        ArrayType ::= Type int                // Type represents the element type, int represents the number of elements (number of elements)
        
        // Struct declaration
        StructTypeDecl ::= StructType VarDecl*
        
        // Variable declaration
        VarDecl ::= Type String
        
        // FunDecl definition (the String is the name of the FunDecl)
        FunDecl ::= Type String VarDecl* Block
        
        // Expressions
        Expr ::= IntLiteral | StrLiteral | CharLiteral | VarExpr | FunCallExpr 
               | BinOp | ArrayAccessExpr | FieldAccessExpr | ValueAtExpr 
               | AddressOfExpr | SizeOfExpr | TypecastExpr
        
        // Literals
        IntLiteral ::= int                 // int stores the value of the integer
        StrLiteral ::= String              // String stores the value of the String
        CharLiteral ::= char               // char stores the value of the character
        
        // Variable (the String is the name of the variable)
        VarExpr ::= String
        
        // Function call (the String corresponds to the name of the function to call and the Expr* is the list of arguments)
        FunCallExpr ::= String Expr*
        
        // Binary operations
        BinOp ::= Expr Op Expr
        Op ::= ADD | SUB | MUL | DIV | MOD | LT | GT | LE | GE | NE | EQ | OR | AND
        
        // Array access expression : Expr[Expr] (e.g. a[10])
        ArrayAccessExpr ::= Expr Expr       // the first Expr is the array, the second one the index
        
        // Field access expression : Expr.String (e.g. a.b)
        FieldAccessExpr ::= Expr String     // the Expr represents the structure, the String represents the name of the field
        
        // Value at expression : *Expr (e.g. *p)
        ValueAtExpr ::= Expr
        
        // Address of an expression : &Expr (e.g. &a[1])
        AddressOfExpr ::= Expr
        
        // Sizeof expression : sizeof(Type) (e.g. sizeof(int*))
        SizeOfExpr ::= Type
        
        // Typecast expression : (Type)Expr (e.g. (int*)malloc(4))
        TypecastExpr ::= Type Expr
        
        
        // Statements
        Stmt ::= Block | While | If | Assign | Return | ExprStmt
        
        // An expression statement (e.g. x=2;)
        ExprStmt ::= Expr
        
        // While loop statement : while (Expr) Stmt;
        While ::= Expr Stmt
        
        // If statement: if (Expr) Stmt1 else Stmt2; (if the second Stmt is null, this means there is no else part)
        If ::= Expr Stmt [Stmt]
        
        // Assignment statement : Expr = Expr; (e.g. x[5] = 2;)
        Assign ::= Expr Expr
        
        // Return statement : (the Expr is optional)
        Return ::= [Expr]
        
        // Block statement (starts with { and ends with } in the source code)
        Block ::= VarDecl* Stmt*
        </code></pre>
      <p>All AST nodes are represented with Java classes...</p>
      <pre><code>ast
        ‚îú‚îÄ‚îÄ AddressOfExpr.java
        ‚îú‚îÄ‚îÄ ArrayAccessExpr.java
        ‚îú‚îÄ‚îÄ ArrayType.java
        ‚îú‚îÄ‚îÄ Assign.java
        ‚îú‚îÄ‚îÄ ASTNode.java
        ‚îú‚îÄ‚îÄ ASTPrinter.java
        ‚îú‚îÄ‚îÄ ASTVisitor.java
        ‚îú‚îÄ‚îÄ BaseType.java
        ‚îú‚îÄ‚îÄ BinOp.java
        ‚îú‚îÄ‚îÄ Block.java
        ‚îú‚îÄ‚îÄ ChrLiteral.java
        ‚îú‚îÄ‚îÄ Expr.java
        ‚îú‚îÄ‚îÄ ExprStmt.java
        ‚îú‚îÄ‚îÄ FieldAccessExpr.java
        ‚îú‚îÄ‚îÄ FunCallExpr.java
        ‚îú‚îÄ‚îÄ FunDecl.java
        ‚îú‚îÄ‚îÄ If.java
        ‚îú‚îÄ‚îÄ IntLiteral.java
        ‚îú‚îÄ‚îÄ Op.java
        ‚îú‚îÄ‚îÄ PointerType.java
        ‚îú‚îÄ‚îÄ Program.java
        ‚îú‚îÄ‚îÄ Return.java
        ‚îú‚îÄ‚îÄ SizeOfExpr.java
        ‚îú‚îÄ‚îÄ Stmt.java
        ‚îú‚îÄ‚îÄ StringLiteral.java
        ‚îú‚îÄ‚îÄ StructType.java
        ‚îú‚îÄ‚îÄ StructTypeDecl.java
        ‚îú‚îÄ‚îÄ Type.java
        ‚îú‚îÄ‚îÄ TypecastExpr.java
        ‚îú‚îÄ‚îÄ ValueAtExpr.java
        ‚îú‚îÄ‚îÄ VarDecl.java
        ‚îú‚îÄ‚îÄ VarExpr.java
        ‚îî‚îÄ‚îÄ While.java
        </code></pre>

      The following analysis was done on the AST:

      Name Analysis: Ensure that the scoping and visibility rules of the language are respected.<br />
      Global and Local Scopes: Identifiers declared in the global scope can be accessed anywhere in the program, A
      variable declared in a block is accessible in the block and all inner blocks of that block, but not accessible
      outside the block. In both cases, it is illegal to declare twice the same identifiers in the same current block.
      <br />
      Shadowing: An identifier declared within a given scope has the same name as an identifier declared in an outer
      scope.
      <br />
      Built-in functions: void print_s(char* s); void print_i(int i); void print_c(char c); char read_c(); int read_i();
      void* mcmalloc(int size);
      <br />
      Type Analysis: Using formal typing rules for Mini C to perform static type-checking.
      <br />
      L-value checking: lvalues (left-values) are the only expressions that can appear on the left-hand side of an
      assignment or as an argument to the address-of operator (&).
      <br />
      <h3>Code Generation</h3>
      <p>
        After verifying the semantics, code needs to be generated to execute the program.
        The program is compiled into <a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a> in order to use
        <a href="https://courses.missouristate.edu/KenVollmar/MARS/">MARS</a>, a cross platform MIPS simulator used for
        educational purposes.
      </p>

      <p>
        We will now produce temporary MIPS code, using virtual registers.
        Virtual registers are representations of real registers, but there is no limit to how many can be used.
        They can be naively interacted with by saving/loading their contents onto the stack every time they are used,
        however this is very slow.
      </p>

      <p>
        Global variables are statically stored in memory using the MIPS <span class="red">.data</span> directive.<br>
        Local variables are stored in memory on the stack, using <span class="red">$sp</span> manipulation.
      </p>

      <p>
        Data padding is an important consideration, as
        <span class="green">sizeof(char) == 1</span>,
        <span class="green">sizeof(int) == 4</span>,
        <span class="green">sizeof(int*) == 4</span>,
        but all fields must align at a 4 byte (32-bit) boundary.
      </p>

      <p>
        Branching is done by converting conditionals into a combination of
        <span class="blue">j</span>, <span class="blue">b</span>, and <span class="blue">bne</span> instructions.
      </p>

      <p>
        Struct/Array access and assignment is done using
        <span class="blue">lw</span> and <span class="blue">sw</span> instructions and considering an offset.
      </p>

      <p>
        Function calls are done using a <span class="blue">j label</span> instruction, and pushing
        <span class="red">$s</span> and <span class="red">$rp</span> onto the stack so they are not overwritten.
      </p>

      <p>
        Stdlib functions are performed using MIPS <span class="red">syscall</span>.
      </p>

      <p>
        Local, static variables (that never have an & operation called on them),
        are represented as virtual registers to allow them to be optimized in register allocation.
        Only the variables that need to be in memory are ever in memory, the ones that can be handled through registers
        are, and the stack is avoided when possible.
      </p>

      <h4>Register Allocation</h4>
      <p>
        Now that we have a complete MIPS program using virtual registers, we need to allocate real registers to our
        program.
        MIPS provides 18 variable registers <span class="red">$s0‚Äìs9</span>, <span class="red">$t0‚Äìt7</span>,
        where s-registers are guaranteed to be saved after a function call.
        MIPS also includes system registers <span class="red">$sp</span>, <span class="red">$ip</span>,
        <span class="red">$mul</span>, etc.
      </p>

      <p>
        In order to keep track of what is being executed when, a
        <a href="https://en.wikipedia.org/wiki/Control-flow_graph">Control-Flow Graph (CFG)</a> is created.
      </p>

      <p>
        <a href="https://www.classes.cs.uchicago.edu/archive/2004/spring/22620-1/docs/liveness.pdf">Liveness
          Analysis</a>
        is performed on the CFG, with each node of the CFG keeping a liveIn and liveOut set.
        This information is then used to create an Interference Graph, where edges represent a point in the program
        execution where both virtual registers are alive at the same time.
      </p>

      <p>
        Note that the CFG nodes are <em>instructions</em>, the Interference Graph nodes are <em>virtual registers</em>.
        Big difference!
      </p>

      <p>
        Finally I implemented
        <a href="https://en.wikipedia.org/wiki/Chaitin%27s_algorithm">Chaitin's Algorithm for Graph Colouring</a>,
        which includes a spill function, where if we were unable to properly colour the interference graph,
        spill is saved onto the stack.
      </p>
    </div>

    <footer class="page-footer">
      <div class="footer-nav">
        <a href="./work.html" class="back-button">‚Üê Back to Code</a>
      </div>
      <p class="copyright">¬© 2022 Ian Laffey</p>
    </footer>
  </div>
</body>

</html>